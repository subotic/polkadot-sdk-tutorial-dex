diff --git a/src/lib.rs b/src/lib.rs
index 275c78b..05b71ba 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -94,6 +94,21 @@ pub mod pallet {
 
         /// Overflow occurred when adding to the total liquidity.
         LiquidityOverflow,
+
+        /// The asset being swapped in is not part of the specified trading pair.
+        InvalidAssetIn,
+
+        /// The asset being swapped out is not part of the specified trading pair.
+        InvalidAssetOut,
+
+        /// The reserves for the asset being swapped out is not sufficient.
+        InsufficientAmountOut,
+
+        /// Attempted to perform an operation that resulted in an overflow
+        ArithmeticOverflow,
+
+        /// Attempted to divide by zero
+        DivisionByZero,
     }
 
     /// The pallet's dispatchable functions ([`Call`]s).
diff --git a/src/liquidity_pool.rs b/src/liquidity_pool.rs
index 09768e5..efad32c 100644
--- a/src/liquidity_pool.rs
+++ b/src/liquidity_pool.rs
@@ -1,11 +1,7 @@
-use crate::pallet::{Config, Error};
-use crate::{AssetBalanceOf, AssetIdOf};
-use codec::{Decode, Encode, MaxEncodedLen};
-use frame_support::dispatch::TypeInfo;
-use frame_support::pallet_prelude::DispatchResult;
-use frame_support::RuntimeDebug;
-use sp_runtime::traits::{CheckedAdd, CheckedSub};
-use std::marker::PhantomData;
+use super::*;
+use sp_runtime::traits::{
+    CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, SaturatedConversion, Saturating, Zero,
+};
 
 #[derive(Clone, Encode, Decode, Eq, PartialEq, RuntimeDebug, MaxEncodedLen, TypeInfo)]
 #[scale_info(skip_type_params(T))]
@@ -63,4 +59,96 @@ impl<T: Config> LiquidityPool<T> {
             .ok_or(Error::<T>::InsufficientLiquidity)?;
         Ok(())
     }
+
+    // Function to swap tokens based on pool reserves
+    pub fn swap(
+        &mut self,
+        asset_in: AssetIdOf<T>,
+        amount_in: AssetBalanceOf<T>,
+        asset_out: AssetIdOf<T>,
+        min_amount_out: AssetBalanceOf<T>,
+    ) -> Result<AssetBalanceOf<T>, DispatchError> {
+        ensure!(
+            self.assets.0 == asset_in || self.assets.1 == asset_in,
+            Error::<T>::InvalidAssetIn
+        );
+        ensure!(
+            self.assets.0 == asset_out || self.assets.1 == asset_out,
+            Error::<T>::InvalidAssetOut
+        );
+
+        let (reserve_in, reserve_out) = if self.assets.0 == asset_in {
+            (self.reserves.0, self.reserves.1)
+        } else {
+            (self.reserves.1, self.reserves.0)
+        };
+
+        let amount_out = Self::get_amount_out(amount_in, reserve_in, reserve_out)?;
+        ensure!(
+            amount_out >= min_amount_out,
+            Error::<T>::InsufficientAmountOut
+        );
+
+        if self.assets.0 == asset_in {
+            self.reserves.0 = self
+                .reserves
+                .0
+                .checked_add(&amount_in)
+                .ok_or(Error::<T>::ReserveOverflow)?;
+            self.reserves.1 = self
+                .reserves
+                .1
+                .checked_sub(&amount_out)
+                .ok_or(Error::<T>::InsufficientReserves)?;
+        } else {
+            self.reserves.0 = self
+                .reserves
+                .0
+                .checked_sub(&amount_out)
+                .ok_or(Error::<T>::InsufficientReserves)?;
+            self.reserves.1 = self
+                .reserves
+                .1
+                .checked_add(&amount_in)
+                .ok_or(Error::<T>::ReserveOverflow)?;
+        }
+
+        Ok(amount_out)
+    }
+
+    // Helper function to calculate the amount of tokens to receive in a swap
+    fn get_amount_out(
+        amount_in: AssetBalanceOf<T>,
+        reserve_in: AssetBalanceOf<T>,
+        reserve_out: AssetBalanceOf<T>,
+    ) -> Result<AssetBalanceOf<T>, DispatchError> {
+        // Ensure that both reserve balances are non-zero
+        ensure!(
+            !reserve_in.is_zero() && !reserve_out.is_zero(),
+            Error::<T>::InsufficientLiquidity
+        );
+
+        // Calculate the input amount with the swap fee (0.3%) by multiplying by 997 (99.7%)
+        let amount_in_with_fee = amount_in
+            .checked_mul(&AssetBalanceOf::<T>::saturated_from(997u128))
+            .ok_or(Error::<T>::ArithmeticOverflow)?;
+        // Calculate the numerator of the output amount formula
+        let numerator = amount_in_with_fee
+            .checked_mul(&reserve_out)
+            .ok_or(Error::<T>::ArithmeticOverflow)?;
+        // Calculate the denominator of the output amount formula
+        let denominator = reserve_in
+            .checked_mul(&AssetBalanceOf::<T>::saturated_from(1000u128))
+            .ok_or(Error::<T>::ArithmeticOverflow)?
+            .checked_add(&amount_in_with_fee)
+            .ok_or(Error::<T>::ArithmeticOverflow)?;
+
+        // Perform integer division to obtain the final output amount
+        let amount_out = numerator
+            .checked_div(&denominator)
+            .ok_or(Error::<T>::DivisionByZero)?;
+
+        // Return the calculated output amount
+        Ok(amount_out)
+    }
 }
